<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>the ascencion</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'VT323', monospace;
            text-transform: lowercase;
            user-select: none;
            cursor: crosshair;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
            image-rendering: pixelated; 
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .hud-text {
            font-size: 24px; 
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            opacity: 1;
        }
        #height-display { font-size: 32px; }
        #biome-display { font-size: 20px; color: #aaa; margin-top: 5px; }
        
        /* Stats Panel */
        #stats-panel {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 120px;
        }
        .stat-row {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .stat-label {
            font-size: 16px;
            color: #ccc;
            text-shadow: 1px 1px 0 #000;
        }
        .bar-container {
            display: flex;
            gap: 2px;
            height: 8px;
        }
        .jump-pip {
            flex: 1;
            background-color: #333;
            border: 1px solid #fff;
        }
        .jump-pip.active {
            background-color: #4caf50;
            box-shadow: 0 0 5px #4caf50;
        }
        #rope-bar-bg {
            width: 100%;
            height: 8px;
            background-color: #333;
            border: 1px solid #fff;
        }
        #rope-bar-fill {
            height: 100%;
            width: 100%;
            background-color: #2196f3;
            transition: width 0.1s linear;
        }
        
        #dialogue-box {
            position: absolute; 
            pointer-events: none;
            display: none; 
        }
        
        #climb-popup {
            position: absolute; bottom: 20%; left: 50%; transform: translate(-50%, 0);
            color: white; text-align: center; opacity: 0; 
            transition: opacity 1s ease-out; 
            pointer-events: none; z-index: 5;
        }
        #climb-popup h1 { font-size: 120px; margin: 0; font-weight: normal; line-height: 0.8; }
        #climb-popup p { font-size: 24px; margin-top: 10px; color: #ccc; }
        #climb-popup span { display: block; font-size: 18px; color: #888; margin-top: 5px; }

        #victory-screen {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; opacity: 0; transition: opacity 2s ease-in-out;
        }
        #victory-screen h1 { font-size: 80px; margin: 0; }
        #victory-screen p { font-size: 30px; opacity: 0.8; }
        
        .touch-zone { display: none; }
        @media (hover: none) and (pointer: coarse) {
            .touch-zone { display: block; position: absolute; bottom: 20px; width: 100px; height: 100px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 1px solid rgba(255,255,255,0.3); }
            #t-left { left: 20px; }
            #t-right { left: 140px; }
            #t-jump { right: 20px; bottom: 20px; }
        }
        
        #crosshair {
            position: absolute;
            width: 10px; height: 10px;
            border: 2px solid white; border-radius: 50%;
            pointer-events: none; transform: translate(-50%, -50%);
            transition: border-color 0.2s; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>

    <div id="climb-popup">
        <h1>climb</h1>
        <p>for it is all you can do</p>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div>
            <div id="height-display" class="hud-text">0m</div>
            <div id="biome-display" class="hud-text">the foothills</div>
            
            <div id="stats-panel">
                <div class="stat-row">
                    <div class="stat-label">jumps</div>
                    <div class="bar-container">
                        <div id="jump-1" class="jump-pip active"></div>
                        <div id="jump-2" class="jump-pip active"></div>
                        <div id="jump-3" class="jump-pip active"></div>
                    </div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">rope</div>
                    <div id="rope-bar-bg">
                        <div id="rope-bar-fill"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="dialogue-box"></div>
        
        <div id="tutorial" class="hud-text" style="opacity: 0.5; text-align: right; font-size: 18px;"> 
            wasd / arrows to move<br>
            space to jump (x3)<br>
            click to grapple<br>
            (click to enable audio)
        </div>
        
        <div id="victory-screen">
            <h1>ascension</h1>
            <p>you have returned to the sky.</p>
            <p style="font-size: 20px; margin-top: 20px;">refresh to dream again</p>
        </div>
    </div>

    <script>
        /**
         * AUDIO SYSTEM
         */
        const AudioSys = {
            ctx: null, noiseBuffer: null, windNode: null, windGain: null, rainNode: null, rainGain: null,
            init: function() {
                if (this.ctx) { if (this.ctx.state === 'suspended') this.ctx.resume(); return; }
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    const bufferSize = this.ctx.sampleRate * 5;
                    this.noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = this.noiseBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                    this.windNode = this.ctx.createBufferSource();
                    this.windNode.buffer = this.noiseBuffer;
                    this.windNode.loop = true;
                    const windFilter = this.ctx.createBiquadFilter();
                    windFilter.type = 'lowpass'; windFilter.frequency.value = 400;
                    this.windGain = this.ctx.createGain();
                    this.windGain.gain.value = 0.0;
                    this.windNode.connect(windFilter); windFilter.connect(this.windGain);
                    this.windGain.connect(this.ctx.destination);
                    this.windNode.start();
                    this.windFilter = windFilter;

                    this.rainNode = this.ctx.createBufferSource();
                    this.rainNode.buffer = this.noiseBuffer;
                    this.rainNode.loop = true;
                    const rainFilter = this.ctx.createBiquadFilter();
                    rainFilter.type = 'lowpass'; rainFilter.frequency.value = 800;
                    this.rainGain = this.ctx.createGain();
                    this.rainGain.gain.value = 0.0;
                    this.rainNode.connect(rainFilter); rainFilter.connect(this.rainGain);
                    this.rainGain.connect(this.ctx.destination);
                    this.rainNode.start();
                } catch(e) { console.error("Audio init failed", e); }
            },
            playThunder: function(distance = 1.0) {
                if (!this.ctx) return;
                const tNode = this.ctx.createBufferSource(); tNode.buffer = this.noiseBuffer;
                const tFilter = this.ctx.createBiquadFilter(); tFilter.type = 'lowpass'; tFilter.frequency.value = 400;
                const tGain = this.ctx.createGain(); tGain.gain.setValueAtTime(0.8 * distance, this.ctx.currentTime);
                tGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1.5);
                tNode.connect(tFilter); tFilter.connect(tGain); tGain.connect(this.ctx.destination);
                tNode.start(); tNode.stop(this.ctx.currentTime + 2.0);
            },
            update: function(heightMeters, biome) {
                if (!this.ctx) return;
                const hRatio = Math.min(1, heightMeters / 10000);
                this.windFilter.frequency.setTargetAtTime(150 + (hRatio * 800), this.ctx.currentTime, 0.1);
                let wVol = 0.05;
                if (heightMeters > 2000) wVol = 0.15; if (heightMeters > 8500) wVol = 0.02;
                this.windGain.gain.setTargetAtTime(wVol, this.ctx.currentTime, 0.1);
                let rVol = 0.0;
                if (biome === 'foothills') rVol = 0.2; if (biome === 'crags') rVol = 0.05;
                this.rainGain.gain.setTargetAtTime(rVol, this.ctx.currentTime, 0.5);
            }
        };

        /**
         * GAME ENGINE CONFIG
         */
        const CANVAS = document.getElementById('gameCanvas');
        const CTX = CANVAS.getContext('2d');
        const VICTORY_SCREEN = document.getElementById('victory-screen');
        const CLIMB_POPUP = document.getElementById('climb-popup');
        const BIOME_DISPLAY = document.getElementById('biome-display');
        const TUTORIAL = document.getElementById('tutorial');
        const CROSSHAIR = document.getElementById('crosshair');
        
        const JUMP_PIPS = [
            document.getElementById('jump-1'),
            document.getElementById('jump-2'),
            document.getElementById('jump-3')
        ];
        const ROPE_BAR = document.getElementById('rope-bar-fill');
        
        const GAME_WIDTH = 480;
        const GAME_HEIGHT = 270;
        
        // Physics
        const GRAVITY = 0.22; 
        const FRICTION = 0.85;
        const MOVE_SPEED = 0.5;
        const JUMP_FORCE = -4.8; 
        const TERMINAL_VELOCITY = 35.0; 
        
        // Grapple Constants
        const GRAPPLE_RANGE = 250; 
        const GRAPPLE_SPEED = 16; 
        const GRAPPLE_PULL = 0.15; 
        const GRAPPLE_COOLDOWN_FRAMES = 60; 
        
        const BLOCK_SIZE = 16;
        const MAX_HEIGHT_METERS = 10000;
        const MAX_HEIGHT_PIXELS = MAX_HEIGHT_METERS * 10;
        
        const BIOMES = {
            foothills: { name: 'the foothills', color: '#2b3a42', sky: '#1a1a1a' },
            crags: { name: 'the crags', color: '#555555', sky: '#2d3436' },
            frost: { name: 'the frost', color: '#dfe6e9', sky: '#b2bec3' },
            void: { name: 'the void', color: '#2d004d', sky: '#000000' }
        };

        const PALETTE = { grass: '#4caf50', tent: '#5d4037', fire: '#ff5722', wood: '#795548', treeTrunk: '#3e2723', treeLeaf: '#2e7d32' };

        let camera = { x: 0, y: 0 };
        let frameCount = 0;
        let scoreHeight = 0;
        let gameEnded = false;
        let endingPhase = 0; 
        let endingTimer = 0;
        let climbPopupShown = false;
        let currentBiome = 'foothills';
        let lightningIntensity = 0; 
        
        const keys = { up: false, down: false, left: false, right: false, jump: false };
        const mouse = { x: 0, y: 0, clicked: false, screenX: 0, screenY: 0 };

        const player = {
            x: 0, y: 0, w: 10, h: 14, vx: 0, vy: 0,
            grounded: false, 
            jumps: 0, maxJumps: 3, 
            facingRight: true,
            wings: false,
            rotation: 0,
            grapple: { state: 'idle', x: 0, y: 0, targetX: 0, targetY: 0, cooldown: 0 }
        };

        // Inner Monologue Data
        let playerMonologue = { text: "", alpha: 0, timer: 0 };
        const PLAYER_THOUGHTS = {
            100: "damn, this is gonna be a long climb.",
            200: "air feels thinner already.",
            300: "legs burning.",
            400: "don't look down.",
            500: "half a kilometer.",
            600: "getting colder.",
            700: "keep moving.",
            800: "almost 1k.",
            900: "...",
            1000: "its getting windier.",
            10000: "is this really it?"
        };
        let lastThoughtHeight = -1;

        let blocks = []; 
        let particles = []; 
        let npcs = []; 
        let decor = []; 
        const orb = { x: 0, y: 0, active: false };

        const DIALOGUES = [
            "the path is long.", "watch your step.", "do not rush.",
            "use your rope.", "breathe.", "the sky awaits."
        ];

        const cobblestonePattern = [
            [0.9, 1.0, 0.9, 1.0], [1.0, 0.9, 1.0, 0.9],
            [0.9, 1.0, 0.9, 1.0], [1.0, 0.9, 1.0, 0.9]
        ];

        function init() {
            CANVAS.width = GAME_WIDTH;
            CANVAS.height = GAME_HEIGHT;
            
            generateTutorial();
            generateMountain(-100);

            // SAFE SPAWN LOGIC:
            const groundY = GAME_HEIGHT - BLOCK_SIZE;
            player.x = 50; 
            player.y = groundY - 150; 

            window.addEventListener('keydown', e => handleKey(e.code, true));
            window.addEventListener('keyup', e => handleKey(e.code, false));
            
            window.onmousedown = (e) => {
                AudioSys.init(); TUTORIAL.style.opacity = 0;
                if(e.button === 0 && endingPhase === 0) { mouse.clicked = true; fireGrapple(); }
            };
            window.onmouseup = () => { mouse.clicked = false; releaseGrapple(); };
            
            window.addEventListener('mousemove', (e) => {
                mouse.screenX = e.clientX; mouse.screenY = e.clientY;
                CROSSHAIR.style.left = e.clientX + 'px'; CROSSHAIR.style.top = e.clientY + 'px';
            });

            loop();
        }

        function generateTutorial() {
            const groundY = GAME_HEIGHT - BLOCK_SIZE;
            for(let x = -150; x < 150; x++) { // Extended floor left
                createBlock(x * BLOCK_SIZE, groundY, true);
            }

            // PARKOUR
            createWoodenBlock(200, groundY - BLOCK_SIZE);
            createWoodenBlock(350, groundY - BLOCK_SIZE);
            createWoodenBlock(350, groundY - BLOCK_SIZE * 2);
            createWoodenBlock(350, groundY - BLOCK_SIZE * 3);
            createWoodenBlock(500, groundY - BLOCK_SIZE * 3);
            createWoodenBlock(650, groundY - BLOCK_SIZE * 3); 
            createWoodenBlock(800, groundY - BLOCK_SIZE * 2);
            createWoodenBlock(880, groundY - BLOCK_SIZE * 4);
            createWoodenBlock(960, groundY - BLOCK_SIZE * 6);
            createWoodenBlock(1150, groundY - BLOCK_SIZE * 10);
            for(let y=0; y<15; y++) createWoodenBlock(1400, groundY - BLOCK_SIZE * y);
            
            // NPCs
            npcs.push({ x: -80, y: groundY - 10, baseY: groundY - 10, hoverOffset: 0, text: "dont trip.", facingLeft: false, alpha: 0 }); // Moved Left
            npcs.push({ x: 100, y: groundY - 10, baseY: groundY - 10, hoverOffset: 0, text: "welcome to the ascent.", facingLeft: false, alpha: 0 });
            npcs.push({ x: 300, y: groundY - 10, baseY: groundY - 10, hoverOffset: 1, text: "jump twice.", facingLeft: true, alpha: 0 });
            npcs.push({ x: 1100, y: groundY - 10, baseY: groundY - 10, hoverOffset: 2, text: "trust your rope.", facingLeft: true, alpha: 0 });
            npcs.push({ x: 1900, y: groundY - 10, baseY: groundY - 10, hoverOffset: 3, text: "begin.", facingLeft: true, alpha: 0 });
        }

        function createWoodenBlock(x, y) {
            blocks.push({ x, y, w: BLOCK_SIZE, h: BLOCK_SIZE, biome: 'wood', grass: null });
        }

        const MOUNTAIN_START_X = 2400; 

        function handleKey(code, pressed) {
            switch(code) {
                case 'KeyA': case 'ArrowLeft': keys.left = pressed; break;
                case 'KeyD': case 'ArrowRight': keys.right = pressed; break;
                case 'KeyW': case 'ArrowUp': keys.up = pressed; break;
                case 'KeyS': case 'ArrowDown': keys.down = pressed; break;
                case 'Space': if(pressed && !keys.jump) tryJump(); keys.jump = pressed; break;
            }
        }

        let highestGenY = GAME_HEIGHT - BLOCK_SIZE;
        let generatedSummit = false;
        let lastCampHeight = 0;
        let mountainWidth = 80; 

        function getBiome(meters) {
            if (meters < 2000) return 'foothills';
            if (meters < 5000) return 'crags';
            if (meters < 8500) return 'frost';
            return 'void';
        }
        
        function createBlock(x, y, forceGrass = false) {
            const heightMeters = Math.max(0, -y / 10);
            const biomeKey = getBiome(heightMeters);
            let hasGrass = false;
            if (biomeKey === 'foothills' && (forceGrass || Math.random() > 0.2)) hasGrass = true;
            const grassData = hasGrass ? { height: 4 + Math.random() * 4, density: 3 + Math.floor(Math.random() * 3), swayOffset: Math.random() * Math.PI } : null;
            blocks.push({ x, y, w: BLOCK_SIZE, h: BLOCK_SIZE, biome: biomeKey, grass: grassData });
        }

        function createCampsite(x, y, heightMeters=0, forceNpc=false) {
            decor.push({ type: 'tent', x: x - 20, y: y - 12 });
            decor.push({ type: 'campfire', x: x, y: y - 5 });
            
            let chance = Math.max(0, 1 - (heightMeters/8000));
            if(forceNpc || Math.random() < chance) {
                npcs.push({ x: x + 20, y: y - 10, baseY: y - 10, hoverOffset: Math.random() * Math.PI * 2, text: DIALOGUES[Math.floor(Math.random() * DIALOGUES.length)], facingLeft: true, alpha: 0 });
            }
        }

        function generateMountain(limitY) {
            if (generatedSummit) return;
            while (highestGenY > limitY) {
                if (-highestGenY >= MAX_HEIGHT_PIXELS) { generateSummit(); generatedSummit = true; return; }
                highestGenY -= BLOCK_SIZE;
                let currentHeightMeters = -highestGenY / 10;
                let currentMountainWidth = Math.max(15, mountainWidth - (currentHeightMeters / 300));
                let drift = Math.sin(highestGenY * 0.005) * 50;
                let baseStartX = MOUNTAIN_START_X + (GAME_WIDTH / 2 - (currentMountainWidth * BLOCK_SIZE / 2) + drift);

                for (let i = 0; i < currentMountainWidth; i++) createBlock(baseStartX + i * BLOCK_SIZE, highestGenY);

                let ledgeChance = 0.8; 
                let difficultyMod = currentHeightMeters / 10000; 
                let gapSize = Math.floor(1 + (difficultyMod * 4)); 
                
                if (Math.abs(highestGenY) % (BLOCK_SIZE * (3 + gapSize)) < BLOCK_SIZE) {
                    let stickOut = Math.floor(Math.random() * 3) + 3; 
                    stickOut = Math.max(1, Math.floor(stickOut - (difficultyMod * 3))); 
                    let side = Math.random() > 0.5 ? -1 : 1;
                    let ledgeX = side === -1 ? baseStartX - (stickOut * BLOCK_SIZE) : baseStartX + (currentMountainWidth * BLOCK_SIZE);
                    for(let k=0; k<stickOut; k++) createBlock(ledgeX + (side === 1 ? k*BLOCK_SIZE : k*BLOCK_SIZE), highestGenY);
                    if (currentHeightMeters - lastCampHeight > 500) { createCampsite(ledgeX + (BLOCK_SIZE), highestGenY, currentHeightMeters); lastCampHeight = currentHeightMeters; }
                }
            }
        }

        function generateSummit() {
            const summitY = highestGenY - BLOCK_SIZE;
            const centerX = MOUNTAIN_START_X + GAME_WIDTH / 2; 
            for(let i = -10; i < 14; i++) createBlock(centerX + (i * BLOCK_SIZE), summitY, false);
            orb.x = centerX + (2 * BLOCK_SIZE); orb.y = summitY - 20; orb.active = true;
        }

        function tryJump() {
            if (endingPhase > 0) return;
            if (player.grapple.state === 'hooked') {
                releaseGrapple();
                player.vy = JUMP_FORCE;
                spawnParticles(player.x + player.w/2, player.y + player.h, 'jump');
                player.jumps = 1; 
                return;
            }
            if (player.grounded || player.jumps < player.maxJumps) {
                player.vy = JUMP_FORCE;
                if (!player.grounded) spawnParticles(player.x + player.w/2, player.y + player.h, 'jump');
                player.grounded = false; player.jumps++;
            }
        }

        function fireGrapple() {
            if (player.grapple.state !== 'idle') return;
            const rect = CANVAS.getBoundingClientRect();
            const scaleX = GAME_WIDTH / rect.width; const scaleY = GAME_HEIGHT / rect.height;
            const mx = (mouse.screenX - rect.left) * scaleX; const my = (mouse.screenY - rect.top) * scaleY;
            const worldMouseX = mx - camera.x; const worldMouseY = my - camera.y;

            let dx = worldMouseX - (player.x + player.w/2);
            let dy = worldMouseY - (player.y + player.h/2);
            let len = Math.sqrt(dx*dx + dy*dy);
            dx /= len; dy /= len;

            // RAYCAST CHECK
            let rx = player.x + player.w/2;
            let ry = player.y + player.h/2;
            let hit = false;
            let targetX = 0; let targetY = 0;

            for(let i=0; i<GRAPPLE_RANGE; i+=10) {
                rx += dx * 10; ry += dy * 10;
                for(let b of blocks) {
                    if(rx > b.x && rx < b.x + b.w && ry > b.y && ry < b.y + b.h) {
                        hit = true; targetX = rx; targetY = ry; break;
                    }
                }
                if(hit) break;
            }

            if (!hit) return;

            player.grapple.state = 'firing';
            player.grapple.x = player.x + player.w/2; player.grapple.y = player.y + player.h/2;
            player.grapple.targetX = targetX; player.grapple.targetY = targetY;
            CROSSHAIR.style.borderColor = 'red';
        }

        function releaseGrapple() {
            if (player.grapple.state === 'firing' || player.grapple.state === 'hooked') {
                player.grapple.state = 'cooldown';
                player.grapple.cooldown = GRAPPLE_COOLDOWN_FRAMES; 
                CROSSHAIR.style.borderColor = 'grey';
            }
        }

        function updatePhysics() {
            if (gameEnded) return;

            // --- ENDING ---
            if (endingPhase === 1) { 
                player.vx *= 0.9; player.vy = -2.0; endingTimer++;
                if (endingTimer > 180) { 
                    endingPhase = 2; endingTimer = 0; 
                    createBlock(player.x - 20, player.y + 40, false); createBlock(player.x, player.y + 40, false); createBlock(player.x + 20, player.y + 40, false); 
                    player.vy = 0; 
                }
                return; 
            }
            if (endingPhase === 2) { 
                player.vy += 0.1; 
                if (player.y > orb.y - 100) { player.y = orb.y - 100; player.vy = 0; endingPhase = 3; endingTimer = 0; }
                return;
            }
            if (endingPhase === 3) { endingTimer++; if (endingTimer > 60) { player.wings = true; endingPhase = 4; endingTimer = 0; } return; }
            if (endingPhase === 4) { player.vx += 0.1; player.vy -= 0.05; endingTimer++; if (endingTimer > 180) { gameEnded = true; VICTORY_SCREEN.style.opacity = 1; VICTORY_SCREEN.style.display = 'block'; } return; }

            // --- MOVEMENT ---
            if (keys.left) { player.vx -= MOVE_SPEED; player.facingRight = false; }
            if (keys.right) { player.vx += MOVE_SPEED; player.facingRight = true; }
            player.vx *= FRICTION; player.vy += GRAVITY;
            if(player.vy > TERMINAL_VELOCITY) player.vy = TERMINAL_VELOCITY;

            // --- GRAPPLE ---
            if (player.grapple.state === 'cooldown') {
                player.grapple.cooldown--;
                if (player.grapple.cooldown <= 0) { player.grapple.state = 'idle'; CROSSHAIR.style.borderColor = 'white'; }
            } else if (player.grapple.state === 'firing') {
                let gx = player.grapple.x; let gy = player.grapple.y;
                let tx = player.grapple.targetX; let ty = player.grapple.targetY;
                let dist = Math.sqrt((tx - gx)**2 + (ty - gy)**2);
                let dirX = (tx - gx) / dist; let dirY = (ty - gy) / dist;
                player.grapple.x += dirX * GRAPPLE_SPEED; player.grapple.y += dirY * GRAPPLE_SPEED;
                
                let pdx = player.grapple.x - (player.x + player.w/2); let pdy = player.grapple.y - (player.y + player.h/2);
                if (Math.sqrt(pdx*pdx + pdy*pdy) > GRAPPLE_RANGE) {
                    player.grapple.state = 'cooldown'; player.grapple.cooldown = GRAPPLE_COOLDOWN_FRAMES; CROSSHAIR.style.borderColor = 'grey';
                }
                for(let b of blocks) {
                    if(player.grapple.x > b.x && player.grapple.x < b.x+b.w && player.grapple.y > b.y && player.grapple.y < b.y+b.h) {
                        player.grapple.state = 'hooked'; CROSSHAIR.style.borderColor = '#4caf50';
                        for(let i=0; i<3; i++) particles.push({x: player.grapple.x, y: player.grapple.y, vx: (Math.random()-0.5)*2, vy: (Math.random()-0.5)*2, life: 10, type: 'dust', size: 1});
                        break;
                    }
                }
            } else if (player.grapple.state === 'hooked') {
                let pdx = player.grapple.x - (player.x + player.w/2); let pdy = player.grapple.y - (player.y + player.h/2);
                let dist = Math.sqrt(pdx*pdx + pdy*pdy);
                if(dist > 15) {
                    player.vx += (pdx/dist) * GRAPPLE_PULL; player.vy += (pdy/dist) * GRAPPLE_PULL;
                    player.vx *= 0.95; player.vy *= 0.95;
                }
            }

            // --- SUB-STEPPING PHYSICS (Anti-Clip Fix) ---
            const steps = 4; 
            const stepVx = player.vx / steps;
            const stepVy = player.vy / steps;
            
            for(let s=0; s<steps; s++) {
                player.x += stepVx; 
                // Collision Resolution X
                for (let b of blocks) {
                    if(Math.abs(b.x - player.x) > 100 || Math.abs(b.y - player.y) > 100) continue;
                    if (player.x < b.x + b.w && player.x + player.w > b.x && player.y < b.y + b.h && player.y + player.h > b.y) {
                        // Use MTV resolution
                        if (stepVx > 0) player.x = b.x - player.w;
                        else if (stepVx < 0) player.x = b.x + b.w;
                        player.vx = 0; 
                    }
                }

                player.y += stepVy; 
                if(s===0) player.grounded = false; 
                // Collision Resolution Y
                for (let b of blocks) {
                    if(Math.abs(b.x - player.x) > 100 || Math.abs(b.y - player.y) > 100) continue;
                    if (player.x < b.x + b.w && player.x + player.w > b.x && player.y < b.y + b.h && player.y + player.h > b.y) {
                        if (stepVy > 0) { player.y = b.y - player.h; player.grounded = true; player.jumps = 0; }
                        else if (stepVy < 0) { player.y = b.y + b.h; }
                        player.vy = 0;
                    }
                }
            }

            // --- NPC UPDATES ---
            for(let npc of npcs) {
                npc.y = npc.baseY + Math.sin((frameCount * 0.05) + npc.hoverOffset) * 5;
                let dist = Math.sqrt((player.x - npc.x)**2 + (player.y - npc.y)**2);
                let targetAlpha = (dist < 80) ? 1 : 0;
                npc.alpha += (targetAlpha - npc.alpha) * 0.1;
                npc.textOffset = (1 - npc.alpha) * 10;
            }

            // --- ORB CHECK ---
            if (orb.active && endingPhase === 0) {
                let dist = Math.sqrt((player.x - orb.x)**2 + (player.y - orb.y)**2);
                if(dist < 30) {
                    endingPhase = 1; player.grapple.state = 'idle'; if(AudioSys.gainNode) AudioSys.gainNode.gain.value = 0;
                }
            }
        }

        function spawnParticles(x, y, type) {
            if (type === 'fire') particles.push({ x, y, vx: (Math.random()-0.5)*0.5, vy: -Math.random()*1.5, life: 60, type: 'fire', size: Math.random()*4 + 2 });
            else if (type === 'jump') for(let i=0; i<5; i++) particles.push({ x, y, vx: (Math.random()-0.5)*2, vy: Math.random(), life: 30, type: 'dust', size: 2 });
            else if (type === 'rain') particles.push({ x, y, vx: (Math.random()-0.5)*0.5, vy: 5 + Math.random()*2, life: 100, type: 'rain', size: 2 });
            else if (type === 'snow') particles.push({ x, y, vx: (Math.random()-0.5)*1, vy: 1 + Math.random(), life: 200, type: 'snow', size: 3 });
        }

        function updateEnvironment() {
            const targetY = -player.y + GAME_HEIGHT * 0.6;
            camera.y += (targetY - camera.y) * 0.1;
            const targetX = -player.x + GAME_WIDTH * 0.5;
            camera.x += (targetX - camera.x) * 0.1;

            scoreHeight = Math.floor(Math.max(0, -player.y / 10));
            document.getElementById('height-display').innerText = scoreHeight + "m";
            
            // UI Update
            const remainingJumps = player.maxJumps - player.jumps;
            JUMP_PIPS.forEach((pip, i) => { if (i < remainingJumps) pip.classList.add('active'); else pip.classList.remove('active'); });
            
            let ropePercent = 100;
            if (player.grapple.state === 'cooldown') ropePercent = 100 - ((player.grapple.cooldown / GRAPPLE_COOLDOWN_FRAMES) * 100);
            else if (player.grapple.state === 'firing' || player.grapple.state === 'hooked') ropePercent = 0; 
            ROPE_BAR.style.width = ropePercent + '%'; ROPE_BAR.style.backgroundColor = (ropePercent === 100) ? '#2196f3' : '#555';

            let newBiome = getBiome(scoreHeight);
            if(newBiome !== currentBiome) { currentBiome = newBiome; BIOME_DISPLAY.innerText = BIOMES[currentBiome].name; }

            if (!climbPopupShown && scoreHeight < 50) {
                CLIMB_POPUP.style.opacity = 1; setTimeout(() => { CLIMB_POPUP.style.opacity = 0; }, 1000); climbPopupShown = true; 
            }
            if (highestGenY > -camera.y - GAME_HEIGHT && !generatedSummit) generateMountain(highestGenY - GAME_HEIGHT * 2);
            
            // Player Monologue Logic
            if (PLAYER_THOUGHTS[scoreHeight] && scoreHeight !== lastThoughtHeight) {
                playerMonologue.text = PLAYER_THOUGHTS[scoreHeight];
                playerMonologue.timer = 180; // 3 seconds
                playerMonologue.alpha = 0;
                lastThoughtHeight = scoreHeight;
            }
            if (playerMonologue.timer > 0) {
                playerMonologue.alpha += (1 - playerMonologue.alpha) * 0.1;
                playerMonologue.timer--;
            } else {
                playerMonologue.alpha += (0 - playerMonologue.alpha) * 0.1;
            }

            AudioSys.update(scoreHeight, currentBiome);
            if (Math.random() < 0.0005) { lightningIntensity = 1.0; AudioSys.playThunder(1.0); }
            if (lightningIntensity > 0) lightningIntensity -= 0.05;

            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life--;
                if (p.type === 'snow') p.x += Math.sin(frameCount * 0.01) * 0.5;
                if(p.life <= 0 || p.y > -camera.y + GAME_HEIGHT) particles.splice(i,1);
            }

            let spawnRate = 0.0;
            if (currentBiome === 'foothills') spawnRate = 0.3; if (currentBiome === 'frost' || currentBiome === 'crags') spawnRate = 0.2; 
            if (Math.random() < spawnRate) {
                let type = currentBiome === 'foothills' ? 'rain' : 'snow';
                spawnParticles(-camera.x + Math.random()*GAME_WIDTH, -camera.y - 10, type);
            }
            if (frameCount % 5 === 0) { 
                for(let d of decor) {
                    if(d.type === 'campfire' && d.x + camera.x > -50 && d.x + camera.x < GAME_WIDTH + 50 && d.y + camera.y > -50 && d.y + camera.y < GAME_HEIGHT + 50) {
                         spawnParticles(d.x + BLOCK_SIZE/2, d.y + BLOCK_SIZE/2, 'fire');
                    }
                }
            }
        }

        function drawCobblestone(blockX, blockY, blockW, blockH, biome) {
            if(biome === 'wood') {
                CTX.fillStyle = PALETTE.wood; CTX.fillRect(blockX, blockY, blockW, blockH);
                CTX.strokeStyle = '#5d4037'; CTX.strokeRect(blockX+2, blockY+2, blockW-4, blockH-4);
                return;
            }
            const patternSize = cobblestonePattern.length; const pixelSize = blockW / patternSize;
            const hex = BIOMES[biome].color;
            let r = parseInt(hex.slice(1,3), 16); let g = parseInt(hex.slice(3,5), 16); let b = parseInt(hex.slice(5,7), 16);
            for (let i = 0; i < patternSize; i++) {
                for (let j = 0; j < patternSize; j++) {
                    const shade = cobblestonePattern[i][j];
                    CTX.fillStyle = `rgb(${r*shade},${g*shade},${b*shade})`;
                    CTX.fillRect(Math.floor(blockX + j * pixelSize), Math.floor(blockY + i * pixelSize), Math.ceil(pixelSize), Math.ceil(pixelSize));
                }
            }
        }

        function draw() {
            CTX.fillStyle = BIOMES[currentBiome].sky;
            CTX.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            CTX.save();
            CTX.translate(Math.floor(camera.x), Math.floor(camera.y));

            // Beam
            if (endingPhase > 0) {
                CTX.fillStyle = `rgba(255, 255, 255, 0.2)`;
                CTX.fillRect(orb.x - 20, -99999, 40, orb.y + 100000);
            }

            // Blocks
            for (let b of blocks) {
                if (b.x + b.w + camera.x < -50 || b.x + camera.x > GAME_WIDTH + 50 || b.y + b.h + camera.y < -50 || b.y + camera.y > GAME_HEIGHT + 50) continue;
                drawCobblestone(b.x, b.y, b.w, b.h, b.biome);
                if (b.grass) {
                    const g = b.grass; CTX.strokeStyle = PALETTE.grass; CTX.lineWidth = 1; CTX.beginPath();
                    for(let i=0; i<g.density; i++) {
                        let offset = Math.sin(frameCount * 0.05 + g.swayOffset + i) * 2;
                        let gx = b.x + (i * (b.w / g.density)) + 2; let gy = b.y;
                        CTX.moveTo(gx, gy); CTX.quadraticCurveTo(gx + offset, gy - g.height/2, gx + offset*1.5, gy - g.height);
                    }
                    CTX.stroke();
                }
            }

            // Decor
            for (let d of decor) {
                if (d.type === 'tent') {
                    CTX.fillStyle = PALETTE.tent; CTX.beginPath(); CTX.moveTo(d.x, d.y + 12); CTX.lineTo(d.x + 10, d.y); CTX.lineTo(d.x + 20, d.y + 12); CTX.fill();
                } else if (d.type === 'campfire') { CTX.fillStyle = '#333'; CTX.fillRect(d.x, d.y + 12, 16, 4); }
                else if (d.type === 'tree') {
                    // Pixelated Tree Style
                    CTX.fillStyle = PALETTE.treeTrunk; 
                    CTX.fillRect(d.x + d.w/2 - 4, d.y + 20, 8, d.h - 20); // Trunk
                    
                    CTX.fillStyle = PALETTE.treeLeaf;
                    // Draw leaves as stacked rectangles for pixel look
                    CTX.fillRect(d.x, d.y + 20, d.w, 10); // Bottom layer
                    CTX.fillRect(d.x + 4, d.y + 10, d.w - 8, 10); // Mid layer
                    CTX.fillRect(d.x + 8, d.y, d.w - 16, 10); // Top layer
                }
            }

            // NPCs
            for (let npc of npcs) {
                if (npc.alpha <= 0.01) continue;
                CTX.fillStyle = `rgba(0,0,0, ${npc.alpha})`; CTX.beginPath(); CTX.moveTo(npc.x - 6, npc.y + 10); CTX.lineTo(npc.x, npc.y - 10); CTX.lineTo(npc.x + 6, npc.y + 10); CTX.fill();
                CTX.fillStyle = `rgba(255,255,255, ${npc.alpha})`; CTX.beginPath();
                if(npc.facingLeft) { CTX.moveTo(npc.x, npc.y - 6); CTX.lineTo(npc.x - 8, npc.y - 4); CTX.lineTo(npc.x, npc.y - 2); } 
                else { CTX.moveTo(npc.x, npc.y - 6); CTX.lineTo(npc.x + 8, npc.y - 4); CTX.lineTo(npc.x, npc.y - 2); }
                CTX.fill();
                // Text
                CTX.font = "normal 16px 'VT323'";
                CTX.fillStyle = `rgba(255,255,255, ${npc.alpha})`; CTX.textAlign = "center";
                CTX.fillText(npc.text, npc.x, npc.y - 20 - npc.textOffset);
            }

            if (orb.active) {
                CTX.fillStyle = '#FFF'; CTX.shadowBlur = 20; CTX.shadowColor = '#FFF'; CTX.beginPath(); CTX.arc(orb.x, orb.y, 10 + Math.sin(frameCount*0.1)*2, 0, Math.PI*2); CTX.fill(); CTX.shadowBlur = 0;
            }

            CTX.save();
            if (endingPhase > 0) {
                CTX.translate(player.x + 5, player.y + 7);
                CTX.rotate(player.rotation);
                CTX.translate(-(player.x + 5), -(player.y + 7));
            }

            CTX.fillStyle = '#FFF'; CTX.beginPath();
            CTX.moveTo(player.x, player.y + player.h); CTX.lineTo(player.x + player.w, player.y + player.h); CTX.lineTo(player.x + player.w/2, player.y); CTX.fill();
            
            if (player.wings) {
                CTX.strokeStyle = '#FFF'; CTX.lineWidth = 2; CTX.beginPath(); 
                CTX.moveTo(player.x, player.y + 5); CTX.quadraticCurveTo(player.x - 15, player.y - 10, player.x - 20, player.y + 5);
                CTX.moveTo(player.x + 10, player.y + 5); CTX.quadraticCurveTo(player.x + 25, player.y - 10, player.x + 30, player.y + 5);
                CTX.stroke();
            }

            CTX.strokeStyle = '#000'; CTX.lineWidth = 2;
            if(!player.grounded && endingPhase === 0) {
                CTX.beginPath(); CTX.moveTo(player.x+3, player.y+player.h); CTX.lineTo(player.x+1, player.y+player.h+4); CTX.stroke();
                CTX.beginPath(); CTX.moveTo(player.x+player.w-3, player.y+player.h); CTX.lineTo(player.x+player.w-1, player.y+player.h+5); CTX.stroke();
            }
            CTX.fillStyle = '#000'; CTX.beginPath();
            if(player.facingRight) { CTX.moveTo(player.x + player.w/2, player.y + 4); CTX.lineTo(player.x + player.w + 2, player.y + 6); CTX.lineTo(player.x + player.w/2, player.y + 8); } 
            else { CTX.moveTo(player.x + player.w/2, player.y + 4); CTX.lineTo(player.x - 2, player.y + 6); CTX.lineTo(player.x + player.w/2, player.y + 8); }
            CTX.fill();
            
            CTX.restore();

            // Player Monologue
            if (playerMonologue.alpha > 0.01) {
                CTX.fillStyle = `rgba(255,255,255, ${playerMonologue.alpha})`;
                CTX.font = "normal 16px 'VT323'";
                CTX.textAlign = "center";
                CTX.fillText(playerMonologue.text, player.x + player.w/2, player.y - 20);
            }

            if (player.grapple.state === 'firing' || player.grapple.state === 'hooked') {
                CTX.strokeStyle = '#fff'; CTX.lineWidth = 1; CTX.beginPath();
                CTX.moveTo(player.x + player.w/2, player.y + player.h/2); CTX.lineTo(player.grapple.x, player.grapple.y); CTX.stroke();
                CTX.fillStyle = '#fff'; CTX.fillRect(player.grapple.x - 2, player.grapple.y - 2, 4, 4);
            }

            for(let p of particles) {
                if(p.type === 'fire') { CTX.fillStyle = `rgba(255, 100, 0, ${p.life/60})`; CTX.fillRect(p.x, p.y, p.size, p.size); } 
                else if (p.type === 'dust') { CTX.fillStyle = `rgba(255,255,255, ${p.life/30})`; CTX.fillRect(p.x, p.y, p.size, p.size); } 
                else if (p.type === 'light') { CTX.fillStyle = `rgba(255,255,255, ${p.life/40})`; CTX.fillRect(p.x, p.y, p.size, p.size); }
                else if (p.type === 'rain') { CTX.fillStyle = `rgba(100,100,255, 0.6)`; CTX.fillRect(p.x, p.y, 1, 4); } 
                else if (p.type === 'snow') { CTX.fillStyle = `rgba(255,255,255, 0.8)`; CTX.fillRect(p.x, p.y, 2, 2); }
            }
            CTX.restore();

            if (lightningIntensity > 0) {
                CTX.fillStyle = `rgba(255, 255, 255, ${lightningIntensity})`;
                CTX.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            }
        }

        function loop() {
            updatePhysics();
            updateEnvironment();
            draw();
            frameCount++;
            requestAnimationFrame(loop);
        }

        init();

    </script>
</body>
</html>
